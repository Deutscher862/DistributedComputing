/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package edu.agh.reactive;

import akka.Done;
import akka.NotUsed;
import akka.actor.typed.ActorSystem;
import akka.actor.typed.javadsl.Behaviors;
import akka.japi.Pair;
import akka.stream.*;
import akka.stream.javadsl.*;


import java.io.IOException;
import java.util.Arrays;
import java.util.concurrent.CompletionStage;

public class App {
    public static void main(String[] args) throws InterruptedException {
        //////////////////////////////////////////
        //TASK 0 - hello
        // create actor system
//
//        final ActorSystem<String> helloSystem =
//                ActorSystem.create(HelloActor.create(), "helloActor");
//        // send messages
//        helloSystem.tell("hello world");
//
//
//        //////////////////////////////////////////
//        //TASK 1 - math operations
//        final ActorSystem<MathActor.MathCommand> mathContext =
//                ActorSystem.create(MathActor.create(), "actorMath");
//        System.out.println("math main: actor system ready");
//
//        // send messages
//        mathContext.tell(new MathActor.MathCommandAdd(5, 3));
//        mathContext.tell(new MathActor.MathCommandMultiply(5, 3, null));
//        mathContext.tell(new MathActor.MathCommandMultiply(5, 2, null));
//        mathContext.tell(new MathActor.MathCommandDivide(15, 3, null));
//        mathContext.tell(new MathActor.MathCommandDivide(15, 5, null));
//
//        mathContext.tell(new MathActor.MathCommandDivide(15, 0, null));
//        Thread.sleep(2000);
//
//        System.out.println("Math main: sending second package of messages");
//        mathContext.tell(new MathActor.MathCommandMultiply(5, 3, null));
//        mathContext.tell(new MathActor.MathCommandMultiply(5, 2, null));
//        mathContext.tell(new MathActor.MathCommandDivide(15, 3, null));
//        mathContext.tell(new MathActor.MathCommandDivide(15, 5, null));
//        System.out.println("Math main: messages send");


        /// TASK 2 - Reactive Streams in Akka Streams
//        final ActorSystem streamSystem = ActorSystem.create(Behaviors.empty(), "streams");
//        final Materializer materializer = Materializer.createMaterializer(streamSystem);
//        final Source<Integer, NotUsed> source = Source.range(1, 100);
//
//        final Flow<Integer, String, NotUsed> flow = Flow.fromFunction((Integer n) -> {
//            System.out.println("Processing: " + n);
//            return n.toString();
//        });
//        final Sink<String, CompletionStage<Done>> sink = Sink.foreach(str -> {
//            System.out.println(str);
//            Thread.sleep(1000);
//        });
//        final RunnableGraph<NotUsed> runnableGraph =
//                source.via(flow)
//                .buffer(7, OverflowStrategy.backpressure())
//                .async()
//                .to(sink);
//
//        runnableGraph.run(materializer);

        // TASK 3 - graph dsl
        final ActorSystem<Object> streamSystem = ActorSystem.create(Behaviors.empty(), "streams");
        final Materializer materializer = Materializer.createMaterializer(streamSystem);
        final Source<Integer, NotUsed> source = Source.range(1, 100);

        final Flow<Integer, Integer, NotUsed> addFlow = Flow.fromFunction((Integer n) -> {
            System.out.println("Adding: " + n);
            return n + 1;
        });

        final Flow<Integer, Integer, NotUsed> multiplyFlow = Flow.fromFunction((Integer n) -> {
            System.out.println("Multiplying: " + n);
            return n * 10;
        });

        final Sink<Pair<Integer, Integer>, CompletionStage<Done>> sink = Sink.foreach(n -> System.out.println("Received: " + n));

        RunnableGraph.fromGraph(
                GraphDSL.create(sink, (builder, out) -> {
                    final UniformFanOutShape<Integer, Integer> bcast = builder.add(Broadcast.create(2));
                    final FanInShape2<Integer, Integer, Pair<Integer, Integer>> zipShape = builder.add(Zip.create());
                    final UniformFanInShape<Integer, Pair<Integer, Integer>> zip =
                            UniformFanInShape.create(zipShape.out(), Arrays.asList(zipShape.in0(), zipShape.in1()));
                    final Outlet<Integer> dslSource = builder.add(source).out();

                    builder.from(dslSource)
                            .viaFanOut(bcast)
                            .via(builder.add(addFlow))
                            .viaFanIn(zip)
                            .to(out);

                    builder.from(bcast)
                            .via(builder.add(multiplyFlow))
                            .toFanIn(zip);

                    return ClosedShape.getInstance();
                })).run(materializer);




        try {
            System.out.println(">>> Press ENTER to exit <<<");
            System.in.read();
        } catch (IOException ignored) {
        } finally {
//            greeterMain.terminate();
//            mathContext.terminate();
//            helloSystem.terminate();
//            streamSystem.terminate();
        }
    }
}
